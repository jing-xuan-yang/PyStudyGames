在 Pygame 中实现批量碰撞检测是游戏开发中的核心技能，尤其在物体数量较多时，合理的检测策略能显著提升性能。以下是从基础到高级的多种方法，并附带示例与性能建议。

---

## 1. 基础方法：双重循环（适合少量对象）

适用于对象数量较少（<50）的场景。

```python
objects = [pygame.Rect(x, y, 50, 50) for x, y in [(100,100), (200,150), (300,200)]]

for i in range(len(objects)):
    for j in range(i + 1, len(objects)):
        if objects[i].colliderect(objects[j]):
            print(f"对象 {i} 和 {j} 发生碰撞")
```

- 时间复杂度：O(n²)
- 优点：实现简单
- 缺点：对象多时性能差

---

## 2. 使用 Sprite 和 Group（推荐方式）

Pygame 的 `sprite` 模块提供高效的批量碰撞检测函数。

### 示例：玩家与多个敌人碰撞

```python
class Player(pygame.sprite.Sprite):
    def __init__(self):
        super().__init__()
        self.image = pygame.Surface((50, 50))
        self.image.fill((0, 255, 0))
        self.rect = self.image.get_rect()
        self.rect.center = (400, 300)

class Enemy(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.image = pygame.Surface((50, 50))
        self.image.fill((255, 0, 0))
        self.rect = self.image.get_rect()
        self.rect.topleft = (x, y)

player = Player()
enemies = pygame.sprite.Group()
for i in range(10):
    enemies.add(Enemy(i * 60, 100))

# 检测玩家与任意敌人碰撞
hits = pygame.sprite.spritecollide(player, enemies, False)
if hits:
    print(f"与 {len(hits)} 个敌人碰撞")

# 检测敌人之间碰撞
for enemy in enemies:
    hits = pygame.sprite.spritecollide(enemy, enemies, False)
    if len(hits) > 1:
        print("敌人之间发生碰撞")
```

### 常用碰撞函数

| 函数 | 说明 |
|------|------|
| `spritecollide(sprite, group, dokill)` | 检测单个精灵与组中精灵碰撞 |
| `groupcollide(group1, group2, dokill1, dokill2)` | 检测两组精灵之间碰撞 |
| `spritecollideany(sprite, group)` | 检测是否与组中任意精灵碰撞（更快） |
| `collide_rect`, `collide_circle`, `collide_mask` | 不同精度碰撞检测方式 |

---

## 3. 性能优化：空间分割技术

当对象数量较多（>100）时，使用空间分割可大幅减少不必要的检测。

### 方法一：网格划分（Grid）

将游戏区域划分为网格，仅检测同一格或相邻格中的对象。

```python
class GridCollision:
    def __init__(self, width, height, cell_size=100):
        self.cell_size = cell_size
        self.cols = width // cell_size + 1
        self.rows = height // cell_size + 1
        self.grid = {}

    def get_cell(self, rect):
        x1, y1 = rect.left // self.cell_size, rect.top // self.cell_size
        x2, y2 = rect.right // self.cell_size, rect.bottom // self.cell_size
        cells = []
        for x in range(x1, x2 + 1):
            for y in range(y1, y2 + 1):
                if 0 <= x < self.cols and 0 <= y < self.rows:
                    cells.append((x, y))
        return cells

    def update(self, objects):
        self.grid.clear()
        for obj in objects:
            for cell in self.get_cell(obj.rect):
                self.grid.setdefault(cell, []).append(obj)

    def check_collisions(self):
        collisions = []
        checked = set()
        for cell_objs in self.grid.values():
            for i, obj1 in enumerate(cell_objs):
                for obj2 in cell_objs[i+1:]:
                    pair = tuple(sorted((id(obj1), id(obj2))))
                    if pair not in checked:
                        checked.add(pair)
                        if obj1.rect.colliderect(obj2.rect):
                            collisions.append((obj1, obj2))
        return collisions
```

### 方法二：四叉树（QuadTree）

适合对象分布不均的场景，可动态划分空间。

```python
class QuadTree:
    def __init__(self, boundary, capacity=4):
        self.boundary = boundary  # pygame.Rect
        self.capacity = capacity
        self.objects = []
        self.divided = False

    def subdivide(self):
        x, y, w, h = self.boundary
        hw, hh = w / 2, h / 2
        self.quadrants = [
            QuadTree(pygame.Rect(x, y, hw, hh), self.capacity),
            QuadTree(pygame.Rect(x + hw, y, hw, hh), self.capacity),
            QuadTree(pygame.Rect(x, y + hh, hw, hh), self.capacity),
            QuadTree(pygame.Rect(x + hw, y + hh, hw, hh), self.capacity)
        ]
        self.divided = True

    def insert(self, obj):
        if not self.boundary.colliderect(obj.rect):
            return False
        if len(self.objects) < self.capacity and not self.divided:
            self.objects.append(obj)
            return True
        if not self.divided:
            self.subdivide()
            for o in self.objects:
                for q in self.quadrants:
                    if q.insert(o):
                        break
            self.objects = []
        for q in self.quadrants:
            if q.insert(obj):
                return True
        return False

    def query(self, rect, found=None):
        if found is None:
            found = []
        if not self.boundary.colliderect(rect):
            return found
        for obj in self.objects:
            if obj.rect.colliderect(rect):
                found.append(obj)
        if self.divided:
            for q in self.quadrants:
                q.query(rect, found)
        return found
```

---

## 4. 实战示例：子弹与敌人批量碰撞

```python
class Bullet(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.image = pygame.Surface((10, 20))
        self.image.fill((255, 255, 0))
        self.rect = self.image.get_rect()
        self.rect.center = (x, y)
        self.speed = 10

    def update(self):
        self.rect.y -= self.speed
        if self.rect.bottom < 0:
            self.kill()

class Enemy(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.image = pygame.Surface((50, 50))
        self.image.fill((255, 0, 0))
        self.rect = self.image.get_rect()
        self.rect.topleft = (x, y)
        self.health = 3

    def hit(self):
        self.health -= 1
        if self.health <= 0:
            self.kill()

bullets = pygame.sprite.Group()
enemies = pygame.sprite.Group()

# 游戏循环中
hits = pygame.sprite.groupcollide(bullets, enemies, True, False)
for bullet, enemy_list in hits.items():
    for enemy in enemy_list:
        enemy.hit()
```

---

## 5. 性能对比与建议

| 对象数量 | 推荐方法             | 理由                     |
|----------|----------------------|--------------------------|
| < 50     | 双重循环             | 简单直接，性能可接受     |
| 50-200   | Sprite + Group       | Pygame 内建优化，易用    |
| > 200    | 网格 / 四叉树        | 显著降低检测次数         |
| 不规则形状 | `collide_mask`     | 像素级精度，但性能开销大 |

### 优化技巧

- 使用 `pygame.sprite.Group()` 管理对象
- 及时 `kill()` 移除屏幕外对象
- 使用 `spritecollideany()` 替代 `spritecollide()` 提高性能
- 分层检测：先矩形，再精确检测
- 控制更新频率：如每 2-3 帧检测一次碰撞

---

## 总结

- 小规模：使用双重循环或 `spritecollide`
- 中大规模：使用 `Group` + 碰撞函数
- 超大规模：引入空间分割（网格、四叉树）
- 特殊形状：使用 `collide_mask` 实现像素级检测
- 始终结合性能测试选择合适方案

根据你的游戏规模和对象数量选择合适的碰撞检测策略，将有效提升游戏性能和可维护性。