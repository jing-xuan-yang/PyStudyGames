在 Pygame 中，**没有内置的物理引擎**（如重力、碰撞反弹、刚体等）。我们需要自己编写简单的物理逻辑，或者引入第三方库（如 `pymunk`）。

为了让你深入理解游戏物理的原理，本教程将**手动实现一个轻量级物理系统**，并以 **“李跳跳”（类似微信“跳一跳”的充能跳跃机制）** 为游戏原型。

---

## 1. 物理核心概念

在编写代码前，必须理解游戏物理的三大基石（欧拉积分）：

1.  **加速度 (Acceleration)**: 力产生的效果（如重力 `g = 0.5`）。
2.  **速度 (Velocity)**: 每一帧位置的变化量（`v = v + a`）。
3.  **位置 (Position)**: 物体的坐标（`pos = pos + v`）。

**公式：**
```python
velocity += acceleration      # 速度受加速度影响
position += velocity          # 位置受速度影响
```

---

## 2. 游戏设计：“李跳跳”物理版

### 游戏机制
1.  **充能**：按住鼠标/空格，积蓄跳跃力量（显示力量条）。
2.  **起跳**：松开鼠标，根据力量施加向上的初速度。
3.  **重力**：角色在空中持续受到向下的加速度。
4.  **碰撞**：落在平台上时停止下落。
5.  **镜头**：摄像机跟随角色移动。

---

## 3. 完整代码实现

这是一个可直接运行的单文件示例。为了无需素材，所有图形均通过代码绘制。

```python
import pygame
import math
import sys

# --- 常量配置 ---
WIDTH, HEIGHT = 800, 600
FPS = 60
GRAVITY = 0.6           # 重力加速度
FRICTION = 0.8          # 空气阻力/摩擦力
JUMP_FORCE_MIN = 5      # 最小跳跃力
JUMP_FORCE_MAX = 15     # 最大跳跃力
CHARGE_SPEED = 0.5      # 充能速度

# 颜色
WHITE = (255, 255, 255)
BLACK = (20, 20, 30)
GREEN = (50, 200, 50)
RED = (200, 50, 50)
BLUE = (50, 100, 200)
GRAY = (100, 100, 100)

# --- 物理对象类 ---

class Player(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        # 视觉图像
        self.image = pygame.Surface((30, 30), pygame.SRCALPHA)
        pygame.draw.circle(self.image, GREEN, (15, 15), 15)
        self.rect = self.image.get_rect()
        self.rect.center = (x, y)
        
        # --- 物理属性 ---
        self.pos = pygame.math.Vector2(x, y)  # 精确位置（浮点数）
        self.vel = pygame.math.Vector2(0, 0)  # 速度向量
        self.acc = pygame.math.Vector2(0, 0)  # 加速度
        self.on_ground = False                # 是否在地面
        
        # --- 充能状态 ---
        self.charging = False
        self.charge_power = 0
        self.max_charge = 100

    def update(self, platforms):
        # 1. 应用重力
        self.acc.y = GRAVITY
        
        # 2. 应用摩擦力 (水平方向)
        self.vel.x *= FRICTION
        
        # 3. 积分计算 (物理核心)
        self.vel += self.acc
        self.pos += self.vel
        
        # 4. 更新 Rect (用于碰撞检测)
        self.rect.center = self.pos
        
        # 5. 碰撞检测 (简单的 AABB 碰撞)
        self.on_ground = False
        # 只检测下落时的碰撞，防止卡住
        if self.vel.y >= 0: 
            for platform in platforms:
                if self.rect.colliderect(platform.rect):
                    # 确保是从上方落下的
                    if self.rect.bottom - self.vel.y <= platform.rect.top + 10:
                        self.rect.bottom = platform.rect.top
                        self.pos.y = self.rect.centery
                        self.vel.y = 0
                        self.on_ground = True
                        break
        
        # 6. 边界检查 (掉出屏幕重置)
        if self.pos.y > HEIGHT + 100:
            self.pos.x = 100
            self.pos.y = HEIGHT - 200
            self.vel.y = 0

    def charge(self):
        if self.on_ground:
            self.charging = True
            if self.charge_power < self.max_charge:
                self.charge_power += CHARGE_SPEED

    def release_jump(self):
        if self.charging and self.on_ground:
            self.charging = False
            # 将充能值转换为跳跃力度
            force = JUMP_FORCE_MIN + (self.charge_power / self.max_charge) * (JUMP_FORCE_MAX - JUMP_FORCE_MIN)
            self.vel.y = -force
            self.charge_power = 0
            return True
        self.charging = False
        return False

    def draw_ui(self, screen):
        # 绘制充能条
        if self.charging:
            bar_width = 100
            bar_height = 10
            fill = (self.charge_power / self.max_charge) * bar_width
            rect = pygame.Rect(10, 10, bar_width, bar_height)
            fill_rect = pygame.Rect(10, 10, fill, bar_height)
            pygame.draw.rect(screen, GRAY, rect)
            pygame.draw.rect(screen, RED, fill_rect)
            pygame.draw.rect(screen, WHITE, rect, 2)

# --- 平台类 ---

class Platform(pygame.sprite.Sprite):
    def __init__(self, x, y, w, h):
        super().__init__()
        self.image = pygame.Surface((w, h))
        self.image.fill(BLUE)
        self.rect = self.image.get_rect()
        self.rect.topleft = (x, y)

# --- 粒子效果 (增加打击感) ---

class Particle(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        size = random.randint(4, 8)
        self.image = pygame.Surface((size, size))
        self.image.fill(WHITE)
        self.rect = self.image.get_rect()
        self.rect.center = (x, y)
        self.vel = pygame.math.Vector2(random.uniform(-3, 3), random.uniform(-5, -1))
        self.life = 30

    def update(self):
        self.rect.x += self.vel.x
        self.rect.y += self.vel.y
        self.vel.y += 0.2 # 粒子重力
        self.life -= 1
        if self.life <= 0:
            self.kill()

# --- 摄像机类 ---

class Camera:
    def __init__(self):
        self.offset = pygame.math.Vector2(0, 0)
    
    def update(self, player):
        # 让玩家保持在屏幕左侧 1/3 处
        target_x = -player.pos.x + WIDTH // 3
        # 平滑跟随 (Lerp)
        self.offset.x += (target_x - self.offset.x) * 0.1
        # 限制摄像机不往左超出起点
        self.offset.x = max(self.offset.x, -100)

    def apply(self, rect):
        # 将世界坐标转换为屏幕坐标
        return rect.move(self.offset)

# --- 游戏主循环 ---

import random

def main():
    pygame.init()
    screen = pygame.display.set_mode((WIDTH, HEIGHT))
    pygame.display.set_caption("李跳跳 - 物理引擎教程")
    clock = pygame.time.Clock()
    font = pygame.font.Font(None, 36)

    # 初始化对象
    player = Player(100, HEIGHT - 200)
    all_sprites = pygame.sprite.Group()
    platforms = pygame.sprite.Group()
    particles = pygame.sprite.Group()
    
    all_sprites.add(player)

    # 生成地面和平台
    ground = Platform(0, HEIGHT - 50, 1000, 50)
    platforms.add(ground)
    all_sprites.add(ground)

    # 生成随机平台
    curr_x = 400
    for _ in range(20):
        w = random.randint(100, 200)
        h = 20
        y = HEIGHT - 150 - random.randint(0, 200)
        plat = Platform(curr_x, y, w, h)
        platforms.add(plat)
        all_sprites.add(plat)
        curr_x += random.randint(250, 400)

    camera = Camera()
    running = True
    score = 0

    while running:
        clock.tick(FPS)
        
        # 1. 事件处理
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                player.charge()
            elif event.type == pygame.MOUSEBUTTONUP:
                if player.release_jump():
                    # 跳跃成功生成粒子
                    for _ in range(10):
                        p = Particle(player.rect.centerx, player.rect.bottom)
                        particles.add(p)
                    score += 1

        # 2. 逻辑更新
        # 持续充能
        keys = pygame.key.get_pressed()
        if keys[pygame.K_SPACE] or pygame.mouse.get_pressed()[0]:
            player.charge()
        else:
            if player.charging: # 防止按键松开逻辑冲突
                player.release_jump()

        player.update(platforms)
        particles.update()
        camera.update(player)

        # 3. 绘制
        screen.fill(BLACK)
        
        # 绘制平台 (应用摄像机偏移)
        for plat in platforms:
            screen.blit(plat.image, camera.apply(plat.rect))
            
        # 绘制玩家
        screen.blit(player.image, camera.apply(player.rect))
        
        # 绘制粒子
        for p in particles:
            screen.blit(p.image, camera.apply(p.rect))

        # UI
        player.draw_ui(screen)
        score_text = font.render(f"Jumps: {score}", True, WHITE)
        screen.blit(score_text, (WIDTH - 150, 10))
        
        # 教程提示
        hint = font.render("Hold Mouse/Space to Charge", True, GRAY)
        screen.blit(hint, (WIDTH // 2 - 150, 50))

        pygame.display.flip()

    pygame.quit()
    sys.exit()

if __name__ == "__main__":
    main()
```

---

## 4. 代码详解：物理引擎部分

### 4.1 重力与速度积分
在 `Player.update` 中：
```python
self.acc.y = GRAVITY       # 每帧给 Y 轴加速度
self.vel += self.acc       # 速度 = 速度 + 加速度
self.pos += self.vel       # 位置 = 位置 + 速度
```
这是最基础的 **欧拉积分**。如果不加这个，角色会漂浮在空中。

### 4.2 碰撞分辨率 (Collision Resolution)
物理引擎最难的部分是**碰撞后怎么处理**。
```python
if self.vel.y >= 0:  # 只有下落时才检测
    if self.rect.colliderect(platform.rect):
        # 关键：将玩家底部强行对齐平台顶部
        self.rect.bottom = platform.rect.top
        self.pos.y = self.rect.centery  # 同步精确位置
        self.vel.y = 0                  # 速度清零
        self.on_ground = True
```
**为什么这样做？** 如果不把 `vel.y` 清零，下一帧重力会继续加速，玩家会陷入平台内部（抖动）。

### 4.3 充能跳跃机制
这不是标准物理，而是游戏性物理。
```python
# 充能
self.charge_power += CHARGE_SPEED
# 释放
force = MIN + (power / MAX) * (MAX_FORCE - MIN_FORCE)
self.vel.y = -force  # 直接施加瞬时速度
```
这模拟了“弹簧”的效果：压得越久，反弹力越大。

### 4.4 摄像机跟随 (Camera Follow)
物理世界通常比屏幕大。摄像机本质是一个**偏移量 (Offset)**。
```python
# 目标：让玩家在屏幕左侧 1/3
target_x = -player.pos.x + WIDTH // 3
# 平滑移动 (线性插值 Lerp)
self.offset.x += (target_x - self.offset.x) * 0.1
```
绘制时，所有物体的坐标都要 `+ offset`。

---

## 5. 进阶：使用 Pymunk 专业物理引擎

如果你需要**真实的刚体碰撞、旋转、堆叠、关节**（比如愤怒的小鸟、布娃娃系统），手写物理太累且容易出 Bug。此时应使用 **Pymunk**（Box2D 的 Python 封装）。

### Pymunk 与 Pygame 的区别
| 特性 | 手写物理 (本教程) | Pymunk |
| :--- | :--- | :--- |
| **难度** | 低，易理解 | 中，需学习新概念 |
| **性能** | 物体少时快 | 物体多时优化好 |
| **功能** | 仅基础移动碰撞 | 旋转、质量、摩擦力、关节 |
| **适用** | 平台跳跃、简单射击 | 物理解谜、破坏效果 |

### Pymunk 简单示例
```python
import pymunk
import pymunk.pygame_util

# 1. 创建物理空间
space = pymunk.Space()
space.gravity = (0, 900)  # 设置重力

# 2. 创建刚体 (Body) 和 形状 (Shape)
mass = 1
radius = 10
inertia = pymunk.moment_for_circle(mass, 0, radius)
body = pymunk.Body(mass, inertia)
body.position = (200, 100)
shape = pymunk.Circle(body, radius)
space.add(body, shape)

# 3. 在游戏循环中步进物理
dt = 1.0 / FPS
space.step(dt)  # 计算下一帧物理状态

# 4. 同步到 Pygame 绘制
player.rect.center = body.position
```

---

## 6. 常见问题与优化

### Q1: 角色为什么会卡在平台边缘？
**A:** 碰撞检测太粗糙。
**解决:** 使用 **分离轴定理 (SAT)** 或确保玩家宽度小于平台宽度。在简单游戏中，限制玩家只能在平台中心区域起跳。

### Q2: 跳跃高度不一致？
**A:** 帧率波动导致 `vel` 累加次数不同。
**解决:** 使用 **Delta Time (dt)**。
```python
# 获取两帧之间的时间差 (秒)
dt = clock.tick(FPS) / 1000.0
self.vel.y += GRAVITY * dt  # 速度与时间挂钩
self.pos += self.vel * dt
```
*注：本教程示例为简化代码省略了 dt，但在正式项目中务必加上。*

### Q3: 如何制作“二段跳”？
**A:** 增加一个计数器。
```python
self.jump_count = 0
# 起跳时
if self.on_ground:
    self.jump_count = 0
# 二段跳
if event.key == K_SPACE and self.jump_count < 2:
    self.vel.y = -10
    self.jump_count += 1
```

---

## 7. 总结

通过这个“李跳跳”示例，你掌握了：
1.  **欧拉积分**：如何用代码模拟重力和速度。
2.  **碰撞解决**：如何防止物体穿模。
3.  **游戏手感**：通过充能条和粒子效果增加物理反馈。
4.  **摄像机**：如何在大地图中跟随玩家。

**下一步建议：**
- 尝试添加**水平移动**的物理惯性。
- 尝试添加**旋转**（跳跃时角色自转）。
- 如果要做更复杂的物理（如倒塌的墙壁），请开始学习 **Pymunk**。

这个教程为你打下了游戏物理的基础，现在的你可以根据这个框架制作出属于自己的平台跳跃游戏了！