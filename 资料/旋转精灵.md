在 Pygame 中旋转精灵（Sprite）是常见需求（如飞机、坦克、角色朝向），但直接旋转会导致**图像模糊**和**位置偏移**。

以下是实现旋转的**核心原则**、**完整代码示例**以及**常见陷阱**。

---

## 1. 核心原则（必读）

旋转精灵时必须遵守以下三条规则，否则会出现抖动或画质下降：

1.  **保存原图**：永远保留一份未旋转的原始图像（`original_image`）。
2.  **每次旋转原图**：每一帧都用 `original_image` 旋转出新图像，**不要**在已旋转的图像上继续旋转（否则画质会迅速变糊）。
3.  **固定中心点**：旋转后图像尺寸会变（矩形对角线变长），必须重新设置 `rect.center` 保持位置不变。

---

## 2. 基础示例：原地旋转

这是一个最简单的示例，让一个箭头在屏幕中心旋转。

```python
import pygame
import math

pygame.init()
screen = pygame.display.set_mode((800, 600))
clock = pygame.time.Clock()

class RotatingSprite(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        # 1. 创建原始图像（这里画一个三角形代表箭头）
        self.original_image = pygame.Surface((50, 50), pygame.SRCALPHA)
        pygame.draw.polygon(self.original_image, (255, 0, 0), [(25, 0), (50, 50), (0, 50)])
        
        # 2. 当前图像设为原图
        self.image = self.original_image
        self.rect = self.image.get_rect()
        self.rect.center = (x, y)
        
        self.angle = 0  # 当前角度

    def update(self):
        # 3. 更新角度
        self.angle += 2
        if self.angle >= 360:
            self.angle = 0

        # 4. 旋转原始图像（关键！）
        # pygame.transform.rotate 角度为逆时针
        self.image = pygame.transform.rotate(self.original_image, self.angle)
        
        # 5. 重新获取 rect 并固定中心点（关键！）
        self.rect = self.image.get_rect()
        self.rect.center = (400, 300)  # 保持位置不变

sprite = RotatingSprite(400, 300)
all_sprites = pygame.sprite.Group()
all_sprites.add(sprite)

running = True
while running:
    clock.tick(60)
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    all_sprites.update()
    screen.fill((30, 30, 30))
    all_sprites.draw(screen)
    pygame.display.flip()

pygame.quit()
```

---

## 3. 进阶示例：旋转 + 移动（坦克/飞船模式）

这是游戏开发中最常用的场景：**按左右键旋转，按上键朝当前方向移动**。

### 数学原理
Pygame 坐标系：X 向右，Y 向下。
角度定义：**0 度指向右方**，逆时针增加。
移动计算：
- `dx = cos(角度) * 速度`
- `dy = -sin(角度) * 速度` (注意 Y 轴是向下的，所以要取反)

```python
import pygame
import math

pygame.init()
screen = pygame.display.set_mode((800, 600))
clock = pygame.time.Clock()

class Ship(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        # 原始图像：箭头指向右方 (0 度方向)
        self.original_image = pygame.Surface((40, 40), pygame.SRCALPHA)
        pygame.draw.polygon(self.original_image, (0, 255, 255), [(40, 20), (0, 0), (0, 40)])
        
        self.image = self.original_image
        self.rect = self.image.get_rect()
        self.rect.center = (x, y)
        
        self.angle = 0
        self.speed = 0
        self.max_speed = 5
        self.rotation_speed = 3

    def update(self):
        keys = pygame.key.get_pressed()
        
        # 1. 旋转控制
        if keys[pygame.K_LEFT]:
            self.angle += self.rotation_speed
        if keys[pygame.K_RIGHT]:
            self.angle -= self.rotation_speed
        
        # 2. 加速控制
        if keys[pygame.K_UP]:
            self.speed = min(self.speed + 0.2, self.max_speed)
        else:
            self.speed = max(self.speed - 0.1, 0)  # 摩擦力减速

        # 3. 根据角度计算移动向量
        # math.radians 将角度转为弧度
        rad = math.radians(self.angle)
        dx = math.cos(rad) * self.speed
        dy = -math.sin(rad) * self.speed  # Pygame Y 轴向下，所以取负

        self.rect.x += dx
        self.rect.y += dy

        # 4. 屏幕边界环绕（可选）
        if self.rect.right < 0: self.rect.left = 800
        if self.rect.left > 800: self.rect.right = 0
        if self.rect.bottom < 0: self.rect.top = 600
        if self.rect.top > 600: self.rect.bottom = 0

        # 5. 执行旋转图像操作
        self.image = pygame.transform.rotate(self.original_image, self.angle)
        self.rect = self.image.get_rect(center=self.rect.center)

ship = Ship(400, 300)
all_sprites = pygame.sprite.Group()
all_sprites.add(ship)

running = True
while running:
    clock.tick(60)
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False

    all_sprites.update()
    screen.fill((0, 0, 0))
    all_sprites.draw(screen)
    pygame.display.flip()

pygame.quit()
```

---

## 4. 特殊情况：左右翻转（平台跳跃游戏）

如果是像《超级马里奥》这样的 2D 平台游戏，角色通常只需要**面向左**或**面向右**，不需要 360 度旋转。此时使用 `flip` 性能更好且图像不变形。

```python
class Player(pygame.sprite.Sprite):
    def __init__(self):
        super().__init__()
        # 假设图片默认面向右
        self.original_image = pygame.image.load("player.png").convert_alpha()
        self.image = self.original_image
        self.rect = self.image.get_rect()
        self.facing_right = True

    def update(self):
        keys = pygame.key.get_pressed()
        moved = False
        
        if keys[pygame.K_RIGHT]:
            self.rect.x += 5
            if not self.facing_right:
                self.facing_right = True
                self.image = pygame.transform.flip(self.original_image, True, False)
            moved = True
            
        elif keys[pygame.K_LEFT]:
            self.rect.x -= 5
            if self.facing_right:
                self.facing_right = False
                self.image = pygame.transform.flip(self.original_image, True, False)
            moved = True
```

---

## 5. 常见问题与优化

### Q1: 为什么旋转后位置会乱跳？
**A:** 因为旋转后的矩形包围盒（Bounding Box）大小变了。
**解决:** 每次旋转后，必须执行 `self.rect = self.image.get_rect(center=self.rect.center)`，强制让新图像的中心点等于旧位置的中心点。

### Q2: 为什么旋转多了图像变模糊？
**A:** 因为你是在 `self.image`（已旋转的图）上继续旋转。
**解决:** 始终基于 `self.original_image`（未旋转的图）进行旋转。

### Q3: 0 度方向是哪里？
**A:** Pygame 中 `transform.rotate` 的 0 度是**指向右方**（X 轴正方向），逆时针旋转。
- 0°: →
- 90°: ↑
- 180°: ←
- 270°: ↓
*如果你的素材默认是朝上的，初始化时可以先旋转 90 度保存为原图，或者在计算移动向量时调整角度偏移。*

### Q4: 性能优化
旋转图像是计算密集型操作。
- 如果屏幕上有几百个旋转精灵，帧率会下降。
- **优化方案**：预先计算好 8 个或 16 个方向的图片（如 0°, 45°, 90°...），运行时直接切换图片，而不是实时计算 `rotate`。

```python
# 预旋转示例
self.images = [pygame.transform.rotate(self.original_image, i * 45) for i in range(8)]
# 使用时
self.image = self.images[index]
```

---

## 总结

| 需求 | 推荐方法 | 关键点 |
| :--- | :--- | :--- |
| **360 度自由旋转** | `pygame.transform.rotate` | 保存 `original_image`，固定 `rect.center` |
| **左右朝向（平台游戏）** | `pygame.transform.flip` | 性能更好，无变形 |
| **朝方向移动** | `math.cos/sin` | 注意 Y 轴取反，角度转弧度 |
| **高性能需求** | 预渲染多方向图片 | 避免每帧计算旋转 |

掌握这些技巧后，你就可以制作出类似《小蜜蜂》、《坦克大战》或《 asteroids》（小行星）这样的游戏了。