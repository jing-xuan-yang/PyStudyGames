这是一个 **Pygame 综合开发教程**，将输入、控制、移动、旋转、动画和声音六大核心模块整合在一起。

为了确保你可以**直接运行代码**而无需下载外部素材，本教程中的示例将使用代码动态生成图像和占位声音（实际开发中你会替换为真实资源）。

---

## 1. 输入系统 (Input System)

Pygame 有两种主要检测输入的方式，适用于不同场景。

### 1.1 事件检测 (`pygame.event`)
适用于**单次触发**的动作（如跳跃、射击、暂停）。
```python
for event in pygame.event.get():
    if event.type == pygame.KEYDOWN:  # 按键按下瞬间
        if event.key == pygame.K_SPACE:
            player.shoot()  # 只发射一颗子弹
    if event.type == pygame.MOUSEBUTTONDOWN:  # 鼠标点击
        print("鼠标点击", event.pos)
```

### 1.2 持续检测 (`pygame.key.get_pressed`)
适用于**持续持有**的动作（如移动、加速）。
```python
keys = pygame.key.get_pressed()
if keys[pygame.K_LEFT]:
    player.move_left()  # 持续向左移动
```

### 1.3 鼠标跟随
获取鼠标位置用于瞄准。
```python
mouse_x, mouse_y = pygame.mouse.get_pos()
```

---

## 2. 平滑移动与物理 (Movement & Physics)

直接修改 `rect.x` 会导致移动生硬。引入 **速度 (velocity)** 和 **摩擦力 (friction)** 可以让移动更平滑。

```python
class PhysicsObject:
    def __init__(self):
        self.pos = pygame.math.Vector2(400, 300)  # 使用向量管理位置
        self.vel = pygame.math.Vector2(0, 0)      # 速度向量
        self.friction = 0.95                      # 摩擦力 (0-1)
        self.speed = 0.5                          # 加速度

    def update(self):
        # 1. 应用输入加速度
        keys = pygame.key.get_pressed()
        if keys[pygame.K_UP]:
            self.vel.y -= self.speed
        if keys[pygame.K_DOWN]:
            self.vel.y += self.speed
        if keys[pygame.K_LEFT]:
            self.vel.x -= self.speed
        if keys[pygame.K_RIGHT]:
            self.vel.x += self.speed

        # 2. 应用摩擦力
        self.vel *= self.friction

        # 3. 更新位置
        self.pos += self.vel
        self.rect.center = self.pos
```

---

## 3. 旋转系统 (Rotation)

**核心原则**（再次强调）：
1. 保存 `original_image`。
2. 每次基于 `original_image` 旋转。
3. 旋转后重新设置 `rect.center`。

```python
def rotate_sprite(self, angle):
    # 旋转图像
    self.image = pygame.transform.rotate(self.original_image, angle)
    # 保持中心点不变，防止抖动
    self.rect = self.image.get_rect(center=self.rect.center)
```

---

## 4. 动画系统 (Animation)

动画本质是**按时间切换图片**。通常使用“精灵表”(Sprite Sheet) 或图片列表。

```python
class AnimatedSprite(pygame.sprite.Sprite):
    def __init__(self, images, fps=10):
        super().__init__()
        self.images = images  # 图片列表 [frame1, frame2, frame3...]
        self.image = images[0]
        self.rect = self.image.get_rect()
        
        self.frame = 0
        self.last_update = 0
        self.frame_time = 1000 // fps  # 每帧停留毫秒数

    def update(self):
        now = pygame.time.get_ticks()
        if now - self.last_update > self.frame_time:
            self.last_update = now
            self.frame = (self.frame + 1) % len(self.images)
            old_center = self.rect.center
            self.image = self.images[self.frame]
            self.rect = self.image.get_rect()
            self.rect.center = old_center  # 保持位置
```

---

## 5. 声音系统 (Sound)

区分 **音效 (Sound)** 和 **音乐 (Music)**。
- **Sound**: 短促声音（射击、爆炸），可重叠播放。
- **Music**: 背景音乐，通常只有一首循环。

```python
# 初始化
pygame.mixer.init()

# 加载音效
shoot_sound = pygame.mixer.Sound("shoot.wav")
shoot_sound.set_volume(0.5)  # 音量 0-1

# 加载音乐
pygame.mixer.music.load("bgm.mp3")
pygame.mixer.music.play(-1)  # -1 表示无限循环

# 播放
shoot_sound.play()
```

---

## 6. 综合实战：太空生存游戏

这是一个完整的、可直接运行的游戏示例。它整合了上述所有功能：
- **状态机**：菜单、游戏、结束。
- **玩家**：平滑移动、鼠标瞄准旋转、动画效果。
- **敌人**：追踪玩家。
- **粒子系统**：爆炸动画。
- **声音管理**：安全加载（无文件不报错）。
- **资源生成**：代码自动生成素材，无需下载图片。

### 完整代码 (`main.py`)

```python
import pygame
import math
import random
import sys
import os

# --- 常量配置 ---
WIDTH, HEIGHT = 800, 600
FPS = 60
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (255, 50, 50)
GREEN = (50, 255, 50)
BLUE = (50, 50, 255)
YELLOW = (255, 255, 0)

# --- 资源生成器 (为了无需下载素材即可运行) ---
def create_assets():
    """动态生成游戏素材，实际开发中请替换为 image.load"""
    assets = {}
    
    # 1. 玩家飞船 (三角形)
    surf = pygame.Surface((40, 40), pygame.SRCALPHA)
    pygame.draw.polygon(surf, GREEN, [(20, 0), (40, 40), (0, 40)])
    assets['player'] = surf

    # 2. 敌人 (圆形)
    surf = pygame.Surface((30, 30), pygame.SRCALPHA)
    pygame.draw.circle(surf, RED, (15, 15), 15)
    assets['enemy'] = surf

    # 3. 子弹 (小矩形)
    surf = pygame.Surface((10, 20), pygame.SRCALPHA)
    pygame.draw.rect(surf, YELLOW, (0, 0, 10, 20))
    assets['bullet'] = surf

    # 4. 爆炸粒子 (小方块列表，模拟动画)
    particles = []
    for i in range(3):
        surf = pygame.Surface((10 + i*5, 10 + i*5), pygame.SRCALPHA)
        surf.fill((255, 100 + i*50, 0))
        particles.append(surf)
    assets['explosion'] = particles

    return assets

# --- 声音管理器 ---
class SoundManager:
    def __init__(self):
        self.enabled = True
        try:
            pygame.mixer.init()
            # 实际开发中取消下面注释并放入文件
            # self.shoot_sound = pygame.mixer.Sound("shoot.wav")
            # self.explosion_sound = pygame.mixer.Sound("explosion.wav")
            # pygame.mixer.music.load("bgm.mp3")
            self.shoot_sound = None
            self.explosion_sound = None
        except Exception:
            self.enabled = False
            print("声音初始化失败，将静音运行")

    def play_sound(self, name):
        if not self.enabled: return
        if name == "shoot" and self.shoot_sound:
            self.shoot_sound.play()
        elif name == "explode" and self.explosion_sound:
            self.explosion_sound.play()

    def play_music(self):
        if not self.enabled: return
        try:
            pygame.mixer.music.play(-1)
        except:
            pass

# --- 游戏对象类 ---

class Player(pygame.sprite.Sprite):
    def __init__(self, image):
        super().__init__()
        self.original_image = image
        self.image = self.original_image
        self.rect = self.image.get_rect()
        self.rect.center = (WIDTH // 2, HEIGHT // 2)
        
        self.pos = pygame.math.Vector2(self.rect.center)
        self.vel = pygame.math.Vector2(0, 0)
        self.angle = 0
        self.speed = 0.5
        self.friction = 0.92
        self.health = 100

    def update(self):
        # 1. 输入与移动
        keys = pygame.key.get_pressed()
        if keys[pygame.K_w]: self.vel.y -= self.speed
        if keys[pygame.K_s]: self.vel.y += self.speed
        if keys[pygame.K_a]: self.vel.x -= self.speed
        if keys[pygame.K_d]: self.vel.x += self.speed

        self.vel *= self.friction
        self.pos += self.vel
        
        # 边界检查
        self.pos.x = max(0, min(WIDTH, self.pos.x))
        self.pos.y = max(0, min(HEIGHT, self.pos.y))
        self.rect.center = self.pos

        # 2. 旋转 (朝向鼠标)
        mouse_x, mouse_y = pygame.mouse.get_pos()
        dx = mouse_x - self.rect.centerx
        dy = mouse_y - self.rect.centery
        self.angle = math.degrees(math.atan2(-dy, dx))  # 计算角度
        
        # 执行旋转
        self.image = pygame.transform.rotate(self.original_image, self.angle)
        self.rect = self.image.get_rect(center=self.rect.center)

class Bullet(pygame.sprite.Sprite):
    def __init__(self, x, y, angle):
        super().__init__()
        self.image = pygame.Surface((10, 20), pygame.SRCALPHA)
        pygame.draw.rect(self.image, YELLOW, (0, 0, 10, 20))
        self.rect = self.image.get_rect()
        self.rect.center = (x, y)
        
        # 根据角度计算速度向量
        rad = math.radians(angle)
        self.vel = pygame.math.Vector2(math.cos(rad) * 10, -math.sin(rad) * 10)
        
        # 旋转子弹图像
        self.image = pygame.transform.rotate(self.image, -angle)
        self.rect = self.image.get_rect(center=self.rect.center)

    def update(self):
        self.rect.x += self.vel.x
        self.rect.y += self.vel.y
        if not screen.get_rect().colliderect(self.rect):
            self.kill()

class Enemy(pygame.sprite.Sprite):
    def __init__(self, player):
        super().__init__()
        self.image = pygame.Surface((30, 30), pygame.SRCALPHA)
        pygame.draw.circle(self.image, RED, (15, 15), 15)
        self.rect = self.image.get_rect()
        self.player = player
        
        # 随机从屏幕边缘生成
        if random.choice([True, False]):
            self.rect.x = random.choice([0, WIDTH])
            self.rect.y = random.randint(0, HEIGHT)
        else:
            self.rect.x = random.randint(0, WIDTH)
            self.rect.y = random.choice([0, HEIGHT])
            
        self.speed = random.uniform(1, 3)

    def update(self):
        # 简单追踪逻辑
        dx = self.player.rect.centerx - self.rect.centerx
        dy = self.player.rect.centery - self.rect.centery
        dist = math.hypot(dx, dy)
        if dist != 0:
            dx, dy = dx / dist, dy / dist
            self.rect.x += dx * self.speed
            self.rect.y += dy * self.speed

class Particle(pygame.sprite.Sprite):
    """爆炸效果"""
    def __init__(self, pos, images):
        super().__init__()
        self.images = images
        self.image = images[0]
        self.rect = self.image.get_rect()
        self.rect.center = pos
        self.frame = 0
        self.last_update = 0
        self.frame_rate = 50

    def update(self):
        now = pygame.time.get_ticks()
        if now - self.last_update > self.frame_rate:
            self.last_update = now
            self.frame += 1
            if self.frame >= len(self.images):
                self.kill()
            else:
                old_center = self.rect.center
                self.image = self.images[self.frame]
                self.rect = self.image.get_rect()
                self.rect.center = old_center

# --- 游戏主类 ---
class Game:
    def __init__(self):
        pygame.init()
        global screen
        screen = pygame.display.set_mode((WIDTH, HEIGHT))
        pygame.display.set_caption("太空生存 - 综合教程")
        self.clock = pygame.time.Clock()
        self.font = pygame.font.Font(None, 36)
        
        self.assets = create_assets()
        self.sound_mgr = SoundManager()
        self.state = "MENU"  # MENU, PLAYING, GAMEOVER
        self.running = True
        
        self.all_sprites = pygame.sprite.Group()
        self.bullets = pygame.sprite.Group()
        self.enemies = pygame.sprite.Group()
        self.particles = pygame.sprite.Group()
        self.player = None

    def new_game(self):
        # 重置游戏数据
        self.all_sprites.empty()
        self.bullets.empty()
        self.enemies.empty()
        self.particles.empty()
        self.player = Player(self.assets['player'])
        self.all_sprites.add(self.player)
        self.score = 0
        self.state = "PLAYING"
        self.sound_mgr.play_music()

    def handle_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False
            
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_SPACE:
                    if self.state == "MENU" or self.state == "GAMEOVER":
                        self.new_game()
                    elif self.state == "PLAYING":
                        # 射击
                        bullet = Bullet(self.player.rect.centerx, self.player.rect.centery, self.player.angle)
                        self.all_sprites.add(bullet)
                        self.bullets.add(bullet)
                        self.sound_mgr.play_sound("shoot")

    def update(self):
        if self.state == "PLAYING":
            self.all_sprites.update()
            
            # 生成敌人
            if random.randint(1, 60) == 1:
                enemy = Enemy(self.player)
                self.all_sprites.add(enemy)
                self.enemies.add(enemy)
            
            # 碰撞：子弹打敌人
            hits = pygame.sprite.groupcollide(self.enemies, self.bullets, True, True)
            for hit in hits:
                self.score += 10
                # 生成爆炸
                for _ in range(5):
                    p = Particle(hit.rect.center, self.assets['explosion'])
                    self.all_sprites.add(p)
                    self.particles.add(p)
                self.sound_mgr.play_sound("explode")

            # 碰撞：敌人撞玩家
            if pygame.sprite.spritecollide(self.player, self.enemies, False):
                self.state = "GAMEOVER"

    def draw(self):
        screen.fill(BLACK)
        
        if self.state == "MENU":
            text = self.font.render("Press SPACE to Start", True, WHITE)
            rect = text.get_rect(center=(WIDTH//2, HEIGHT//2))
            screen.blit(text, rect)
            
        elif self.state == "PLAYING":
            self.all_sprites.draw(screen)
            score_text = self.font.render(f"Score: {self.score}", True, WHITE)
            screen.blit(score_text, (10, 10))
            
        elif self.state == "GAMEOVER":
            text = self.font.render("GAME OVER - Press SPACE to Restart", True, RED)
            rect = text.get_rect(center=(WIDTH//2, HEIGHT//2))
            screen.blit(text, rect)
            
        pygame.display.flip()

    def run(self):
        while self.running:
            self.clock.tick(FPS)
            self.handle_events()
            self.update()
            self.draw()
        pygame.quit()
        sys.exit()

# --- 入口 ---
if __name__ == "__main__":
    Game().run()
```

---

## 7. 代码解析与关键点

### 7.1 游戏循环架构 (`Game` 类)
使用类管理游戏状态是最佳实践。
- `new_game()`: 初始化变量，重置组。
- `handle_events()`: 处理输入。
- `update()`: 处理逻辑（移动、碰撞、生成）。
- `draw()`: 处理渲染。
这种分离让代码易于维护和扩展。

### 7.2 向量数学 (`pygame.math.Vector2`)
在 `Player` 类中，使用 `Vector2` 处理位置和速度比单独处理 `x, y` 更优雅，且方便进行加减乘除运算。

### 7.3 旋转与瞄准
```python
dx = mouse_x - self.rect.centerx
dy = mouse_y - self.rect.centery
self.angle = math.degrees(math.atan2(-dy, dx))
```
`atan2` 是计算角度的标准函数。注意 `dy` 取负，因为屏幕 Y 轴向下，而数学坐标系 Y 轴向上。

### 7.4 粒子系统
`Particle` 类展示了如何实现简单的动画。通过切换 `self.image` 并控制时间间隔 (`frame_rate`)，实现爆炸效果。这比单纯消失更有“打击感”。

### 7.5 资源安全
`create_assets()` 函数确保即使你没有图片文件，游戏也能运行。在实际项目中，你会将其替换为：
```python
self.image = pygame.image.load("player.png").convert_alpha()
```

---

## 8. 下一步学习建议

1.  **替换素材**：找一些免费的飞船、敌人 PNG 图片替换 `create_assets` 中的绘制代码。
2.  **添加音效**：下载 `.wav` 文件，取消 `SoundManager` 中的注释。
3.  **增加功能**：
    -   **道具系统**：敌人掉落血包或双发子弹。
    -   **关卡系统**：分数越高，敌人生成速度越快。
    -   **Boss 战**：每 1000 分出现一个高血量 Boss。
4.  **性能优化**：如果敌人超过 200 个，尝试使用 `pygame.sprite.RenderUpdates` 或空间分割算法（如前文提到的四叉树）。

这个教程涵盖了 2D 游戏开发 80% 的核心逻辑。掌握它后，你已经具备制作完整独立游戏的能力了。